# -*- coding: utf-8 -*-
"""DFS_LR1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGtEYPAy0rspg_0F_IvNREWVunL0eQ-4
"""

import streamlit as st
from collections import deque

# --- Define the directed graph ---
graph = {
    'A': ['B', 'D'],
    'B': ['C', 'E', 'G'],
    'C': ['A'],
    'D': ['C'],
    'E': ['H'],
    'F': [],
    'G': ['F'],
    'H': ['F', 'G']
}

# --- BFS function ---
def bfs(graph, start):
    visited = []
    queue = deque([start])
    traversal_order = []

    while queue:
        node = queue.popleft()
        if node not in visited:
            visited.append(node)
            traversal_order.append(node)
            for neighbor in sorted(graph[node]):  # Alphabetical order
                if neighbor not in visited:
                    queue.append(neighbor)
    return traversal_order


# --- DFS function ---
def dfs(graph, start, visited=None):
    if visited is None:
        visited = []
    visited.append(start)

    for neighbor in sorted(graph[start]):  # Alphabetical order
        if neighbor not in visited:
            dfs(graph, neighbor, visited)
    return visited


# --- Streamlit interface ---
st.title("Breadth-First Search (BFS) & Depth-First Search (DFS)")
st.write("This app demonstrates both **BFS** and **DFS** algorithms using the directed graph below.")

# Choose algorithm
algorithm = st.radio("Select Algorithm:", ("Breadth-First Search (BFS)", "Depth-First Search (DFS)"))

# Choose starting node
start_node = st.selectbox("Select starting node:", list(graph.keys()), index=0)

# Run the selected algorithm
if st.button("Run Search"):
    if algorithm == "Breadth-First Search (BFS)":
        result = bfs(graph, start_node)
        st.success(f"**BFS Traversal starting from '{start_node}':**")
        st.write(" → ".join(result))

        # Optional: Show level info for BFS
        st.subheader("Traversal Process (Levels)")
        visited = []
        queue = deque([start_node])
        level = 0
        while queue:
            level_nodes = list(queue)
            st.write(f"**Level {level}:** {', '.join(level_nodes)}")
            next_level = deque()
            for node in level_nodes:
                if node not in visited:
                    visited.append(node)
                    for neighbor in sorted(graph[node]):
                        if neighbor not in visited and neighbor not in queue:
                            next_level.append(neighbor)
            queue = next_level
            level += 1

    else:  # DFS
        result = dfs(graph, start_node)
        st.success(f"**DFS Traversal starting from '{start_node}':**")
        st.write(" → ".join(result))

        st.subheader("Traversal Process (Step-by-Step)")
        for i, node in enumerate(result, 1):
            st.write(f"**Step {i}:** Visit {node}")

# Show adjacency list
st.subheader("Graph Structure (Adjacency List)")
for node, neighbors in graph.items():
    st.write(f"**{node}** → {', '.join(neighbors) if neighbors else '(no neighbors)'}")

st.caption("Developed for Search Algorithms Lab — BFS & DFS Example")

